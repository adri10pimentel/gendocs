Aula 1:
Aula 2:
Aula 3:
Aula 4:
Aula 5:
Aula 6:
Arquiteto de Software

Objetivo: Projetar aplicacoes utilizando conceitos de arquitetura e 
boas praticas de desenvolvimento.

Artefatos entregaveis: Frameworks, arquiteturas(definindo a arquitetura) / modelos de referencia, 
analise de cenarios / desafios tecnicos.
O Arquiteto de SW e como se fosse uma biblioteca de solucoes de SW para o cenario e toma a 
melhor decisao com bate na estrategia da empresa e no desafio tecnico.
Qual componente, tecnologia e abordagem sera usada.
Conceitos chave: Qualidade, Flexibilidade, Performance, Reuso, Testabilidade,
Escalabilidade e Seguranca.

Ele precisa saber o custo da ferramenta, tem uma serie de requisitos pessoais e pode nao ser para todo o desenvolvedor.
saber lidar com restricoes e proibicoes.

Figura escolhida:
Arquitetura hexagonal aka: arquitetura de portas e adapters
Entenda tudo disso, mas use somente o que for necessario.

Primary/Driving Adapters																				Secondary/Driven Adapters
																	Command Query Bus		|		Event Bus
USER		HTTP
			|					-> ADMIN GUI Views & Controllers 	-> Queries	|					CQBUS->Message BUS->Message Queue Adapter->Message Queue
COMPUTER	|		WEB SERVER	-> SOAP/REST Controllers			-> Commands	|					EBUS->Event BUS Adapter-|^
			|					-> CONSUMER GUI Views & Controllers	-> Services	-> Application Core	Notifications->SMS Adapter->SMS Server
USER		|																	|								 ->Email Adapter->Mailing Server
																				|					Shared Kernel
USER	->	CLI-command line interface	-> console commands						|					Search->Search adapter->Search Engine(ie. Elasticsearch)
																									Persistence->ORM Adapter->ORM->MySQL Adapter->PRD DB(MySQL)
																																|->SqLite Adapter->TST DB(SqLite)
																																
																		User Interface		|		Infrastructure
																		
Aula 7:
Outros tipos de arquitetos:

Arquiteto de dados
Arquiteto de TI -> data centers, etc.
Arquiteto de nuvem
Etc...

A IASA reconhece a existencia deles, porem os entende como customizados para atender a necessidades especificas das empresas.

Aula 8:
Perfil do Arquiteto de SW

Objetivo principal: projetar uma solucao compativel com os requisitos atuais da corporacao, que tenha flexibilidade suficiente 
para comportar mudancas futuras e/ou novos requisitos resultantes de sua evolucao ao longo do tempo.

ser adaptavel a cultura da empresa
Para empresas conservadoras: muitos anos de existencia, multinacional, nao gere revolucoes se adapte ao que existe.
Para empresas startups: buscar inovacao, se adaptar ao budget restrito e exigem resultado atraves de tecnologias modernas.

ser responsavel pela qualidade tecnica do entregavel, atuar no apoio tecnico de toda equipe e ajudar nas decisoes necessarias.
Obs: nao so esperar que o time atenda a qualidade tecnica esperada, acompanhar e ajustar e reconhecer as limitacoes tecnicas da equipe,
muitas vezes tem de ser instrutor para prover treinamentos para a equipe, buscar ter um backup de si mesmo, alguem que consiga assumir seu lugar,
sucessor, caso voce venha a subir de nivel para C-level, ajudar a equipe a tomar decisoes, a equipe e um organismo vivo, sinergia entre o arquiteto e a equipe.

Promover comunicacao do time, envolvendo e delegando as decisoes de arquitetura com toda a equipe.
Obs.: ser um bom orador para envolver o time, nao da para ser introspectivo, precisa explicar o que quer, para que as pessoas possam te defender caso necessario.
para que as pessoas saibam o porque de voce esta ali.

Aula 9:
Requisitos tecnicos "Hard skills":
1- Profundo conhecimento em programacao e componentizacao.
	Componentizacao: transformar um conjunto de algoritmos e tecnologias em um componente responsavel.
	ter experiencias solidas em projetos, atuar ao lado de outros arquitetos, conquistar cases de sucesso.

2- dominar amplamente alguma plataforma de desenvolvimento, frameworks, ferramentas e modelagem tecnica.
exemplo eu: plataforma web, frameworks: .net, angular, ferramentas: IDE`s, modelagem tecnica: EA, Bizzagi, Power Designer

3- Conhecer abordagens de arquitetura e padroes para a solucao de problemas. (para a area de atuacao)
Obs.: Arquitetura web e diferente de uma arquitetura industrial por exemplo.

4- Conhecer as tecnicas de design de codigo e qualidade para permitir uma facil manutencao e testabilidade.
um arquiteto pode entregar um template ou uma primeira funcionalidade codificada para ser usado como referencia e doutrinacao dos demais membro dos times.

Aula 10:
Requisitos pessoais "Soft skills"

Lideranca - envolve pessoas, lider natural, onde for colocado, com o tempo ele vai liderar aquelas pessoas, nao e apenas conquistar mas sim envolver, um lider 
tem de ser respeitado nao porque ele tem poder ou por estar a frente, mas porque ele e a melhor pessoa para escolher o destino.

Comunicacao - um lider precisa ser comunicativo, uma pessoa nao comunicativa nao dificilmente vai ter lideranca, mesmo que lideranca nao esteja ligada a ser 
apenas um bom comunicador, investir tempo para aperfeicoar o meu nivel de comunicacao, comunicar com pessoas que me lideram, comunicacao fluente e autoconfianca.

Proatividade - ele nao pode esperar as coisas acontecerem, precisa prever os acontecimentos, estar preparados antes de ocorrer e tomar iniciativa, antenado e 
sempre ligado no que vai acontecer.

mindset empreendedor - mente empreendedora, postura de dono, buscar formas rentaveis de otimizar o uso de recursos e maximizar resultados da empresa, como se eu
fosse a pessoa que esta perdendo dinheiro.

humildade - ter cuidado como se porta, reconhecer suas limitacoes, falhas e defeitos, nunca se colocar como quem sabe de tudo, manda e desmanda.

resumo:
	tomar boas decisoes
	estar aberto a criticas e sugestoes
	ser um profundo pesquisador
	ser didatico
	saber delegar tarefas
	saber questionar: colocar em palavras a sua visao para que a pessoa reflita aquilo que esta colocando sem gerar confronto
	saber conduzir as discussoes->saber a hora de comecar a falar, parar de falar, dar abertura para as pessoas, poderar os pontos da discussao
	saber conversar com diferentes niveis hierarquicos
	estar sempre aberto a novas tecnologias ->Leitura, eventos, etc...
	estar atualizado com o mercado
	ter maturidade e equibilibrio emocional->nunca demonstrar fraqueza ou emocao agressiva
	pensamento estrategico
	reconhecer e assumir os proprios erros e de sua equipe->se coloque a frente e proteja seus liderados
	
Aula 11:
Mitos sobre o arquiteto de software

1-O arquiteto nao programa, apenas projeta, documenta e lidera.
2-Um desenvolvedor senior pode assumir o papel de arquiteto.
3-O arquiteto e um desenvolvedor com muito tempo de experiencia, "arquiteto de cadeira".
4-Para ser um arquiteto basta estudar tecnicas de arquitetura de software.
5-O arquiteto trabalha em ambiente isolado ou diferenciado da equipe.
6-O arquiteto o e uma autoridade tecnico e nao deve ser questionado.
7-O arquiteto e um gerente tecnico.
8-O arquiteto e um profissional com graducao em arquitetura de software.
9-O arquiteto e um profissional que esta na liderenca de um projeto.
Obs.: cobranca de prazo, etc, e um acumulo de funcao que o arquiteto deve aceitar.

Modulo OOP
Aula 12:
Orientacao a objeto - OOP

Pilares fundamentais:

Estado, Comportamento, abstracao, Heranca, Poliformismo, Encapsulamento.

E essencial possuir um claro conhecimento dos principios da orientacao a objetos para poder aplicar as melhores
praticas de design de codigo, padroes e abordagens de arquitetura.

Objetivo: buscar o baixo acoplamento e a alta coesao.

Acoplamento: dependencia direta entre um objeto e outro.
Coesao: Objetos executando uma unica responsabilidade livres de uma dependencia direta com um outro objeto.

Aula 13:
Estado e comportamento

Classe: estrutura de codigo que tem a funcao de mapear um objeto do mundo real(uma pessoa, um objeto real, etc).
Objeto: quando temos uma classe  instanciada com valores na memoria.
Estado: estado e representado pelas propriedades da classe quando ela contem x informacoes ela esta em um estado x.
Comportamento: e quando geramos uma nova informacao atraves da propria classe, ex. metodo calcularIdade, apos receber a informacao data de nascimento..
Comportamento2: o metodo tambem pode alterar o estado da classe, por exemplo um metodo pode alterar o nome da pessoa.

resumo:
estado -> entender que a classe possui propriedade que possuem informacoes que estao na instancia da classe(objeto).
comportamento -> sao metodos que processam a informacao(gerando novas informacoes) ou que alteram o estado da entidade.

metodo -comportamento
estado -propriedades

Aula 14:
Heranca

Funcionario herdando de pessoa

O Funcionario e uma pessoa, quando herdamos de pessoa estamos extendendo a classe pessoa com a especializacao de funcionario.
poderiamos estender por exemplo a classe pessoa como cliente, pois ambos sao pessoas.

nem sempre a heranca deve ser utilizada.

toda ver que herdamos de uma outra classe, estamos absorvendo o estado e os comportamentos daquela outra classe.

para usar a heranca deve usar sempre a frase: a classe que esta herdando eh um classe que esta sendo herdada?
mesmo que o criterio eh um funcione, temos que avaliar se vale ou nao a pena usar heranca ou se estamos somente economizar linhas de codigo na implementacao.

nas proximas aulas vamos entender quando e como utilizar heranca.

Aula 15:
Abstracao

abstracao eh um pilar suportado pela heranca, ou seja oferecer um conjunto que estados e comportamentos que abstraem uma certa especializacao.

exemplo:
classe abstrata eletrodomestico
todo eletrodomestico tem:
nome
voltagem
e se comporta:
ligando
desligando

Obs.: quando temos um metodo abstrato nao somos obrigados a implementar seus comportamentos.
quando eu defindo isso, a classe filha vai ser responsavel por implementar seus proprios comportamentos de acordo com seu funcionamento.
Quando marcamos uma classe com o modificador abstrato estamos proibindo a instancia-la, esta classe soh podera ser herdada, nunca instanciada.

se temos a missao que criar uma super classe para heranca, o conceito de abstract e essencial.

o conceito de abstracao eh a base para o polimorfismo e encapsulamento.

a abstracao pode facilitar e criar regras para que suas classes nao sejam criadas de forma errada.

simplificando abstracao eh: criar conceitos genericos que possam ser abstraidos por outras classes.

Aula 16:
Poliformismo

Poli - muitos, morfismo - comportamento

CafeteiraExpressa e um eletrodomestico, que tem comportamentos privados exemplo: aquecer a agua e moer os graos do cafe.

override - sobreescrever o comportamento de uma classe base para implementar o comportamento, por conta da classe abstrata Eletrodomestico eu sou abrigado a
sobreescrever e implementar.

na classe abstrata podemos ter metodos padrao que nao sejam abstratos e que serao herdados, porem a sobreescrita destes metodos nao e permitida nas classes herdadas.
se quisermos implementar algo e permitir sobreescrever, precisamos adicionar o modificador virtual.

Aula 17:
Encapsulamento

Oque eh?
Encapsular comportamentos atraves da exposicao de metodos publicos e privados.

Encapsulamento e fazer uso de metodos de uma classe sem saber como ele internamente funciona.

o ponto chave do encapsulamento sao os modificadores de acesso.

ref: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers

public - acessivel em qualquer codigo pelo propio o por outro assembly que o referencie.
private - acessivel somente pelo codigo dentro da classe ou estrutura.
protected - acessivel somente pelo codigo de sua classe ou classe derivada.
internal - acessivel por qualquer codigo no mesmo assembly mas nao em outro assembly.
protected internal - acessivel em qualquer codigo no assembly em que foi declarado, mas somente
em uma classe derivada em outro assembly.
private protected - tipo ou membro pode ser acessado por tipos derivados da classe declarada em seu proprio assembly.

Aula 18:
Interface x Implementacao

Sempre e melhor defender o uso de uma interface do que uma simples implementacao pura.

A interface e uma especie de contrato, toda a classe que implementa uma interface e obrigado a implementar os metodos da interface, isso pode
ser confundido com o uso da classe abstrata pois apesar da classe abstrata tambem forcar a implementacao de metodos, tambem implementa alguns comportamentos
derivados, ja a interface e um contrato simples, ou seja, se vc esta implementando esta interface vc e obrigado a fazer a implementacao dos metodos nela presentes.

tem de cumprir o contrato.
podemos criar uma classe fake que nao vai realizar a acao.

implementacao, chamar a classe.

na implementacao, voce usa classes concretas e em caso de alteracao a classe quebra.
a classe que implementa e a classe que esta sendo implementada podem quebrar.

ao usar a abstracao com interfaces, o codigo nao quebra em caso de modificacao de uma classe que implementa a interface, porque esta abstraido atraves do contrato
e nao sendo implementado atraves da implementacao forte da classe concreta.

no caso de alteracao no construtor, resolver atraves da injecao de dependencia como ele ira ensinar mais a frente no curso.

Aula 19:
Heranca x Composicao

Exemplo de heranca->PessoaFisica herda de Pessoa
public clase PessoaFisica : Pessoa

Obs.: conceito chave para pessoa, usar o criterio: eh um... no caso Pessoa Fisica e uma pessoa.

//e adiciona o atributo cpf.
public string cpf;

Exemplo de composicao->
public class PessoaFisica2
public Pessoa pessoa;
public string cpf;

Quando definir entre heranca e composicao?
R: no solid existe um principio que explica se uma classe deve herdar outra ou nao.

Resposta para o momento: desde de que a classe pai  nao sofra nenhuma deformacao de sua proposta, se a classe pai comecar a ser alterada
e criada caracteristicas que nao sao inerentes a sua proposta, eh um sinal que estamos forcando uma situacao que nao era pra acontecer, tbm e importante
observar que as caracteristicas que a classe pai possui tambem tem de atender o que a classe filho espera, uma heranca correta exige harmonia.

caso 2:
Repositorio Generico x Repositorio Especializado

quando herdamos, temos um acoplamento mais forte do que quando abstraimos.

com composicao podemos nos resgaurdar e nao expor metodos desnecessarios.

Obs.: prefira sempre uma composicao a uma heranca, pois favorece ao baixo acoplamento e alta coesao.

https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers

Quiz: se em um projeto de AssemblyA esta herdando de uma classe do AssemblyB, quais metodos do AssemblyB serao visiveis na classe derivada do AssemblyA?
R: metodos que tenham os modificadores public, protected e protected internal.

E em uma classe nao derivada, quais metodos do AssemblyB estarao visiveis?
R: somente os metodos com o modificador public.

Aula 20:
Solid - single responsability principle, open closed principle, Liskov substitution principle, interface segregation principle, dependency invertion principle
Solid esta ligado a OOP, e algo que tem de ser aplicado o tempo todo durante a codificacao.

SOLID e um acronimo dos 5 primeiros principios da programacao orientada a objetos e design de codigo identificados por Robert C Martin(Uncle Bob) por volta 
dos anos 2000.

por volta dos anos 2000, Uncle Bob nao criou ou documentou, ele observou os principios destacados por outras pessoas e os unificou como se fosse uma regra 
de ouro que forma a palavra solid, que representa um codigo solido, forte.

Os principios do SOLID devem ser aplicados para se obter os reais beneficios da programacao orientada a objetos.

nao adianta usar OOP sem utilizar o SOLID, esperando obter algum tipo de beneficio, nao adianta usar somente uma letra ou beneficio, esse nao e um padrao que voce deve escolher ou nao se vai aplicar,
o solid e o fundamento da Orientacao a objetos.

Os beneficios sao:
1- facilidade de manter, adaptar e se ajustar a alteracoes de escopo.
essa frase resume a maior parte das aplicacoes do SOLID, a maior dor das aplicacoes manter, adaptar e ajustar, se nao usamos a escrita de codigo corretamente, 
podemos nao conseguir entregar software ao mesmo tempo que o mercado espera ou para tornar seu produto competitivo.

2- ser testavel e de facil entendimento.
para o ser codigo ser testavel ele precisa ser um bom codigo, se ele nao e testavel, e porque nao e um bom codigo, o bom codigo e um codigo de facil entendimento.

3- ser extensivel para extensivel a alteracoes com o menor esforco necessario.
todos ja devem ter passado por isso, precisar alterar um botao e precisar mexer na aplicacao quase como um todo, pois ela esta toda acoplada.
isso e um sinal de codigo ruim.

4- fornecer o maximo de reaproveitamento.
a orientacao a objetos e uma opcao melhor do que a programacao procedural por oferecer mais opcoes de reaproveitamento de codigo, e se o seu codigo nao oferece
o maximo de reaproveitamento e porque faltou design de codigo por meio dos principios do solid e demais praticas.

5- que permaneca o maximo de tempo possivel em utilizacao.
se nos ouvirmos "se quiser que eu faca isso na aplicacao vou precisar reescreve-la quase que inteira", o programador que fala isso esta errado ao falar,
principalmente se ele tiver criado a aplicacao, pois apesar do software precisar de alteracoes para se adaptar, a alteracao deve ser sempre a minima possivel,
uma aplicacao boa e bem escrita e facil de mexer, tanto de alterar como de acrescentar funcionalidades, o intuito do trabalho e manter o codigo o maximo de tempo
possivel em utilizacao, ate que ele nao seja mais necessario, o sw so sai de utilizacao quando ele nao e mais necessario.

ele nao deve ser reescrito para tentar atender a uma necessidade que ele falhou em atender pela primeira vez.

Problemas evitados com SOLID:
1- Dificuldade ma testabilidade / criacao de testes de unidade.
2- Codigo macarronico / sem estrutura padrao.
o codigo da sinais, nao encontrar padroes e algo grave.
3- Dificuldades em isolar funcionalidades.
muito acoplamento, quando uma classe nao eh so responsavel pelo que ela faz e voce precisa entender tudo aquilo que as outras fazem para que ela faca sentido.
4- Duplicacao de codigo, uma alteracao precisa ser replicada em N pontos.
sem isso perdemos o beneficio da reusabilidade.
5- fragilidade, o codigo quebra facilmente apos alguma mudanca.
em antagonismo a palavra solid que nos remete um codigo solido, forte, inquebravel.

exemplo: alteracao no cadastro de cliente quebrando/impactando o processo de vendas.

ponto chave: evitar problemas em tempo de escrita de codigo.

Modulo SOLID

Aula 21:
SRP - Single responsability principle

"A class should have one, and only one reason to change".
"Uma classe so pode ter, e apenas um motivo para ser modificada".

este e o principio mais simples e mais importante do solid, a responsabilidade definida se da atraves do que a classe tem de fazer, exemplo: uma classe que envia
email, porque ela sera alterada um dia? R: porque neste dia a forma de se mandar email mudou, se alem de enviar email a classe tambem tiver de formatar texto, ela
tambem tiver controle texto, imagem, anexo, ela vai ter mais de um motivo para mudar.

O principio da responsabilidade unica nao se aplica apenas a uma classe, se aplica a tudo, uma camada de negocios so pode tratar de negocios, nao se preocupar com infra
e etc...

nao quer dizer que uma classe so pode ter um metodo, esta mais no porque a classe precisa ser criada.

uma classe que envia email pode ter varios metodos que ajudam a compor o envio de email, mas nao pode fugir da responsabilidade que e o envio de emcil.

sempre pensar: estamos invadindo a responsabilidade que deveria ser de outra classe?

exemplos:

violacao->
temos a classe cliente com suas propriedades para definicao de estado, e temos um comportamento adicionar cliente, ou seja uma classe de entidade que faz a
propria persistencia e envio de email, e isso passa a sua propria responsabilidade.

o problema maior e que e dificil de testar e identificar onde ocorre a falha.

solucao->
obs.: nao e a solucao ideal pois precisa dos demais principios do solid.

gerar mais classes:
cliente->possui os atributos e um comportamento que e a validacao do cliente atraves de verificar o email e o cpf validos.
clienteRepository-> metodo adicionarCliente que conecta com o banco de dados e faz a persistencia,
clienteService -> metodo que orquestra tudo
cpf -> possui o estado e o comportamento de um cpf
email -> possui o estado e o comportamento de um email
emailService -> efetua o disparo de um email

pergunta: mas a classe clienteService nao esta acumulando responsabilidades?
R: nao, a proposta dela e ser um workflow e esta e a sua responsabilidade.

Obs.: podemos afirmar que todos os demais principios sao para atender o SRP, e no final de todos os principios vamos ver que o SRP foi otimizado.

este e o principio mais simples e mais importante, ele nao exige nenhuma tecnica, basta apenas separar.

Aula 22:
OCP - Open closed principle

ponto chave: estender a classe principal em funcionalidades secundarias.

Aula 23:
LSP - Liskov substitution principle

Barbara Liskov foi a primeira mulher dos estados unidos a obter um phd em ciencia da computacao.

ponto chave: subclasses devem ser substituiveis por suas superclasses.

"se nada como um pato, voa como um pato e precisa de baterias, provavelmente voce possui um problema de abstracao"
entendendo:

o pato voa e nada, o pato de banheira e uma especializacao do pato, se no pato de banheira tiver de colocar pilhas e seu estado e comportamento nao puderem
ser substituidos pelo pato original, e porque existe uma desconexao com o pato original de onde houve a heranca.

O LSP e a prova real da heranca.

exemplo: quadrado x retangulo

uma das formas de resolver o LSP e implementando o OCP.

meu insight:
se o seu pai que era sapateiro faleceu e deixou uma sapataria, o filho que vai cuidar dela 100%(herdar de fato) tem de ser sapateiro + administrador + atendente.
sendo sapateiro + administrador + atendente (classe fechada), se o filho for sapateiro + administrador + atendente e skatista(classe estendida) ja atende,
o que ele nao pode e nao ser sapateiro ou adminstrador ou atendente, ele pode ate herdar e tocar o negocio, mas um principio estara sendo ferido e havera um
debito na operacao.

Aula 24:
ISP - Interface segregation principle

"States that no clients should be forced to depend on methods it does not use"
"Clientes nao devem ser forcados a depender de metodos que nao usam".

clientes = classes
uma vez que usamos interfaces nos forcamos as classes a implementar metodos e se os metodos nao sao obrigatorios para determinada classe, ele nao deve ser 
implementado.

ponto chave: muitas interfaces especificas sao melhores que uma interface unica.

Violacao:
Interface ICadastro
	void ValidarDados();
	void SalvarBanco();
	void EnviarEmail();
	
classe implementando ICadastro:
CadastroCliente : ICadastro
	void ValidarDados();
	void SalvarBanco();
	void EnviarEmail();
	
outra classe implementando ICadastro:
CadastroProduto : ICadastro
	void ValidarDados();
	void SalvarBanco();
	void EnviarEmail(); // nao existe um endereco de e-mail para disparar em caso de um novo produto cadastrado.
	
	void EnviarEmail(){
		throw new NotImplementedException("metodo nao implementado");
	}
	
Solucao:
Interface ICadastroCliente
	void ValidarDados();
	void SalvarBanco();
	void EnviarEmail();
	
Interface ICadastroProduto
	void ValidarDados();
	void SalvarBanco();
	
podemos evoluir este principio melhorando a generalizacao, exemplo:

criar a interface ICadastro com o seguinte metodo:
Interface ICadastro
	void SalvarBanco();
	
e fazer as interfaces ICadastroCliente e ICadastroProduto, elas irao forcar a implementacao sobre a classe que as herdar e nao precisam estar explicitadas como
demonstrado abaixo.

Interface ICadastroCliente : ICadastro
	void ValidarDados();
	void EnviarEmail();
	
Interface ICadastroProduto : ICadastros
	void ValidarDados();
	
Obs.: nao estamos fugindo ou negligenciando a especializacao, na verdade estamos apenas forcando um padrao atraves de uma interface mais generica que neste caso e
"para cadastrar algo precisamos salvar no banco de dados".

por mais que seja um principio simples, este principio e o precursor da inversao de controle.

Aula 25:
DIP - Dependendy invertion principle aka inversao de dependencia ou inversao de controle.

"High level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. details should depend on
abstractions."

"Modulos de alto nivel nao devem depender de modulos de baixo nivel, ambos devem depender de abstracoes; abstracoes nao devem depender de detalhes, detalhes devem
depender de abstracoes."

ponto chave: dependa de uma abstracao e nao de uma implementacao.

Explicacao: este principio e o mais importante e e o que da mais sentido ao SOLID, pois sem o DIP o SRP perde um pouco de proposito, pois voce precisa inverter o
controle para ter responsabilidade unica.

Violacao:
public class ClienteService
{
	public string AdicionarCliente(Cliente cliente)
	{
		if(!cliente.Validar())
			return "dados invalidos";
			
		var repo = new ClienteRepository(); //aqui esta a violacao, pois e uma implementacao.
		repo.AdicionarCliente(cliente);
		
		EmailService.Enviar("empresa@empresa.com", "cliente@cliente.com",...);
		
		return "cliente cadastrado com sucesso!";
	}
}

ou seja, se a classe ClienteRepository mudar a ClienteService quebra, e a classe ClienteService nao deve ser obrigada a saber como criar uma instancia da 
ClienteRepository, isso e um acoplamento classico, pois ClienteRepository e um modulo de baixo nivel comparado ao ClienteService.

ClienteRepository esta mais proximo a infra e banco de dados, enquanto ClienteService esta mais proximo ao negocio e as regras de negocio.

principio sendo ferido: um modulo de alto nivel nao deve depender de um modulo de alto nivel.

Solucao:
usamos isp para definir interfaces, pois interfaces especificas sao melhores que uma unica interface.

Interaces:
IClienteRepository
	void AdicionarCliente(Cliente cliente);

IClienteService
	void AdicionarCliente(Cliente cliente);
	
IEmailService
	void EnviarEmail(string de, string para, string assunto, ...);
	
explicacao:
todas as interfaces que tem algum tipo de acao e nao sao uma entidade possuem uma interface para representar o contrato, obrigacao e responsabilidade da classe.

desta forma alteramos a classe ClienteService:

public class ClienteService : IClienteService
{
	private readonly IClienteRepository _clienteRepository;
	private readonly IEmailService _emailService;
	
	public ClienteService(IClienteRepository clienteRepository, IEmailService emailService){
		_clienteRepository = clienteRepository;
		_emailService = emailService;
	}

	public string AdicionarCliente(Cliente cliente)
	{
		if(!cliente.Validar())
			return "dados invalidos";
			
		_clienteRepository.AdicionarCliente(cliente);
		
		_emailService.Enviar("empresa@empresa.com", "cliente@cliente.com",...);
		
		return "cliente cadastrado com sucesso!";
	}
}

explicacao 1: por causa do contrato da interface IClienteService somos obrigados a implementar AdicionarCliente se nao o codigo nem compila.
explicacao 2: no inicio do codigo da classe temos 2 interface sendo utilizadas como propriedades, se tentar usar estar interfaces nao vai funcionar
pois nao tem implementacao, para isso precisamos passar uma instancia de objeto criado que contenha uma implamentacao e estamos fazendo isso atraves da
injecao de dependencia no construtor.

Modulo Dependency injection
Injecao de dependencia e uma forma de aplicar o DIP(aka inversao de controle)

explicacao construtor:
eu declarei como parametros uma instancia do objeto ClienteRepository e uma instancia do objeto EmailService mas eu os declarei com uma interface e nao de suas 
classes, ou seja estou dependendo de uma abstracao e nao da implementacao.

se voce nao e familiarizado com a injecao de dependencia e cair no codigo, e der um go to definition(F12) nao vai encontrar o codigo da implementacao e isso esta
correto, este codigo esta abstraido, nao existe uma relacao direta entre a interface e a classe, isso esta reforcando o principio dependa de interfaces e nao de
classes.

nao conseguimos criar uma instancia de ClienteService se nao passarmos as instancias e essa e a forma correta, pois invertemos o controle.

meu insight:
imaginando um cenario de violacao, onde temos a classe ClienteService que precisa cadastrar novos clientes do banco, entao passamos como parametro o clienteItau
e chamamos o metodo salvar com estes parametros, mais tarde o itau compra um novo banco menor, e precisamos adicionar estes clientes, para funcionar precisariamos
fazer um if cliente == clienteBancoMenor e trabalhar de forma a salvar no banco de dados, funciona, porem nao esta aproveitando os beneficios da OOP, pois o controle
esta dentro da classe implementada.

cenario correto:
temos o contrato(interface) que especifica o minimo de informacoes necessarias atraves das propriedades(estado) e comportamentos(metodos) necessarios
para ser um cliente Itau, e dentra ClienteService estamos injetando o ClienteRepository que sabe como salvar cliente que implementem a interface IClienteItau.
se amanha o banco comprou um banco menor, basta que a classe de cliente do banco menor implemente a interface IClienteItau para que esta possa ser integrada ao
fluxo existente no IClienteService, podendo ter seus comportamentos especificos e tambem seu estado proprio desde de que atenda minimamente o contrato especificado
na interface.

explicacao: a injecao de dependencia nao e a unica forma de inverter controle, temos tambem a AOP - Programacao orientada a aspectos, onde e feita a emissao de
codigo durante a compilacao e existe uma versao de controle.

quando chamamos com a injecao de controle ele diz:
eu nao sei quem e a classe que ira adicionar o cliente, mas eu tenho um contrato e este objeto esta atendendo ao contrato e isso ja e o suficiente para permitir
o funcinamento do fluxo.

pegando o gancho:
meu ClienteRepository que hoje utiliza ado.net para persistir no banco pode ficar intacto caso eu queria testar outro framework de persistencia, por exemplo:

vou criar o clienteRepository2 que ira utilizar Dapper, pois a gestao tecnica decidiu utilizar esta tecnologia e quer testa-la e substituir sem para producao.

neste caso basta que clienteRepository2 atenda ao contrato para integra-lo no fluxo do ClienteService, nao importa como ele ira implementar a persistencia.

conclusao: a classe ClienteService tem apenas uma responsabilidade que e orquestrar a persistencia do cliente no banco de dados, logo se ela e bem especifica, dificilmente
sera alterada, dando espaco para sempre aplicarmos o principio de OCP(podemos ate vetar sua alteracao atraves do scm - source code versioner).

Aula 26:
Registro de generics
Registrando classes genericas no .net core

Aula 27:
Property injection:

Injecao de dependencia sem usar o construtor, mas por propriedade atraves do conteiner [FromServices]
Por padrao sempre devemos fazer injecao de dependencia por construtor, mas se
por algum motivo nao pudermos utilizar em uma determinada classe, temos o recursos
de injecao por propriedade.

injecao por parametro:

public void Index([FromServices]IClienteService clienteService){
	clienteService.AdicionarCliente(new Cliente());
}

existe o recurso, mas o seu uso nao e recomensavel, pois e dificil de testar e
nao e um bom design.

problemas: pode ocorrer violacao do SRP.
solucao: isso pode ser resolvido utilizando um design pattern chamado Facade.

Referencia: documentacao do simple injector.

Aula 28:
Service Locator "Pattern", este e um padrao muito popular e polemico.

private readonly serviceProvider _serviceProvider;

public serviceLocatorController(IServiceProvider serviceProvider)
{
	_serviceProvider = serviceProvider;
}

public void Index(){
	//retorna null se nao estiver registrado
	_serviceProvider.GetRequiredService<IClienteService>.AdicionarCliente(new Cliente());
}

Vantagem:
E uma forma de localizar seus servicos por conta propria.
Imagine que nao quero ou nao posso expor todos os registros no meu container.
Obs.: o serviceProvider nao e interface de um padrao locator, e a interface de service de
um container de injecao de dependencia, o padrao service locator se da quando fazemos uso dessa
interface para localizar por conta propria obter acesso aos servicos.
Desvantagem:
O padrao service locator nao e recomendavel por conta de dificuldade de testar.

tambem e possivel obter a injecao do serviceProvider por propriedade via [FromServices], este padrao 
e menos recomendavel ainda.

esse e reconhecido por muitos, inclusive pelo Eduardo Pires como um anti pattern.

Aula 29:
N Classes : 1 Interface

Public interface IService{
	string Retorno();
}

Public class ServiceA: IService {
	public string Retorno(){
		return "A";
	}
}

Public class ServiceB: IService {
	public string Retorno(){
		return "B";
	}
}

Public class ServiceC: IService {
	public string Retorno(){
		return "C";
	}
}

violacao: ISP.

porem pode acontecer um cenario onde voce precise registrar varias classes com a mesma interface,
como resolver na injecao de dependencia do .net core?

R: registrar as 3 classes da seguinte forma->

services.AddTransient<ServiceA>();
services.AddTransient<ServiceB>();
services.AddTransient<ServiceC>();

apos registrar as 3.
//delegate
service.AddTransient<Func<string, IService>>(serviceProvider -> key =>
{
	switch(key)
	{
		case "A":
			return serviceProvider.GetService<ServiceA>;
		case "B":
			return serviceProvider.GetService<ServiceB>;
		case "C":
			return serviceProvider.GetService<ServiceC>;
		default:
			return null;
	}
});

Ob.: este tipo de implementacao e uma variacao do service locator.

Implementacao no Controller:
public classe MultipasClassesController : Controller
{
	private readonly Func<string, IService> _serviceAcessor;
	
	public MultipasClassesController(Func<string, IService> serviceAcessor)
	{
		_serviceAcessor = serviceAcessor;
	}
	
	public string Index()
	{
		return _serviceAcessor("A").Retorno();
	}
}

Obs.: resolver instancias por chave, service locator e um antipattern, design ambigui e o LSP, a substituicao
de Liskov foi violada.

resolver instancias por chave foi retirada do simple injector, por ser algo errado, porem ha uma maneira de
se fazer pelo menos, maneira esta que nao e recomendavel.

resolver um problema e depois voltar para resolver.

Modulo Clean Code

Aula 30:
Apresentacao Clean Code, livro obrigatorio do Uncle Bob.

O conteudo dessa sessao pode causar desconforto.

Clean Code->

"Elegante e eficiente Codigo limpo faz bem uma coisa." Bjarne Stroutrup
"Simples e direto. Pode ser lido como uma conversa." Grady Booch
"Parece ter sido escrito por alguem que se importa." Michael Feathers -> criou o nome SOLID junto com Uncle Bob.
"Cada rotina que voce le faz o que voce espera." Bjarne Ward Cunningham

Aula 31:
O que e um codigo limpo?

Simples - nao precisa fazer nada alem do necessario e da forma mais simples possivel.
Direto - direto ao ponto resolvendo com simplicidade
Eficiente - nao somente no sentido de escrita, mas tambem em performance.
Sem Duplicidade - nao existe motivos para replicar um codigo.
Elegante - Nao ha problema em caprichar no codigo, utilizacao correta e padrao de cases e bem identado,
bonito na hora de ler quando de olhar como ele esta distribuido, se ele possui um bom design ele e elegante
por si proprio.
Feito com cuidado - voce percebe que quem escreveu se preocupou com o codigo escrito e nao apenas em entregar 
a funcionalidade, isso diz muito sobre quem escreveu o codigo.
Facil de ler - precisa ser especifico e direto de forma simples de ler para nao perder a caracteristica de ser
um codigo limpo.

"Qualquer tolo consegue escrever codigo que um computador entenda. Bons programadores escrevem codigo que humanos
conseguem entender." Martin Fowler

Aula 32: Desculpas e responsabilidades
Desculpas classicas:
	Cronograma apertado -> a escrita de bom codigo deve ser feita o tempo inteiro.
	ponto chave: perguntar a pessoa se quando esta com pressa ela dirige errado, ou cria os filhos errado,
	se faz coisas erradas no casamento, se ela faz uma coisa mal feita por causa de tempo, ela pode fazer todas
	as coisas erradas. -> em fim foi apenas uma desculpa para nao ter se dedidcado na escrita do codigo.

	Meu chefe me pressiona a entregar logo: a pressao realmente existe e pode causar ate problemas psicologicos,
	mas o ponto chave e: o que voce faz, faz bem feito, nao importa as circunstancias.
	
	Quero mostrar produtividade: querer entregar mais codigo, mais rapido, sempre que queremos entregar algo rapido
	a qualidade tem de a cair, um prato de comida cozinha com pressa pode nao ser bom, escrever um codigo que funcione
	e que possa ser usado por bastante tempo e que vai dar o minimo de manutencao do que entregar codigo rapido e ruim.
	por mais que a entrega seja rapida, amanha ou depois outro programador vai ter de atuar nele, a produtividade e falsa
	e fica mascarada, pois no final o trabalho aumenta.
	
	Nao ganho o suficiente para escrever o melhor codigo do mundo!: pior desculpa, se nao esta feliz, precisa procurar
	outro emprego, o codigo nao traduz o quanto ela ganha, mas sim o profissional que ela e. Um profissional que aceitar
	entregar codigo ruim, nao e o codigo que e ruim, mas o profissional. se voce aceitar entregar codigo ruim, mesmo que
	seja dia sim, dia nao, voce esta aceitando ser um profissional ruim as vezes. e isso nao faz sentido, voce nunca vais
	ser bom 100%.
	
	A empresa nao valoriza bom codigo e sim a entrega!: simula uma realidade que nao e verdade, as pessoas que esperam a
	entrega nao sabem ler o codigo, se soubessem eles valorizariam um bom codigo, neste caso eles avaliam a entrega,
	mas entregue algo que:
	1- entregue algo com problema.
	2- entregue algo que quando precise ser alterado levara o dobro do tempo, ou ate mesmo o tempo que demorou pra fazer tudo.
	3- entregue algo que sempre tenha algo pendente a ser melhorado.
	4- entregue algo que tenha falha de performance em funcao do tempo.
	Na verdade, a empresa valoriza o codigo, mas ela nao sabe medir se o codigo e bom ou nao, eles esperam que voce entregue
	rapido e bem feito, se entregamo rapido e mal feito, isso nao e um bom sinal e nenhuma empresa valoriza uma entrega
	rapida e que nao funciona, bom codigo tem de ser escrito independente da empresa, pois ele vai valorizar a sua entrega.
	Se demoramos mais tempo para entregar um codigo bom do que um codigo mal feito, e um sinal que precisamos evoluir
	tecnicamente, ate que o tempo para escrever codigo bom e codigo ruim seja o mesmo, podemos ate entregar um codigo que
	pode ser melhor, nao sendo um codigo ruim.
	
	E de quem e a culpa?
	
	A culpa e sua, a culpa e nossa, nos como desenvolvedores precisamos ter um papel de militar em favor as boas praticas,
	nao da para aceitar que programadores entreguem codigo ruim e consigam trocar de emprego e ganhar mais, temos de militar,
	influenciar as pessoas a sua volta, chame a responsabilidade para si, levando para quem nao conhece como e desenvolver
	codigo. enquanto houver culpados a culpa e nossa, minha funcao deve ser influenciar as pessoas para que elas virem
	influenciadores tambem.
	
	Verdades que nao lhe dizem:
	
	Sua carreira e sua responsabilidade.
	Leia, estude, pratique -> faca disso um habito.
	Va a conferencias -> escolha alguns e va, pegar experiencias e networking.
	Faca cursos -> estimular pessoas a realizar cursos tambem, nao adianta so voce ser capacitado que isso vai ser diluido
	na sua area.
	
	Frizando: nao e da responsabilidade do empregador lhe oferecer cursos, oportunidades ou ate mesmo um projeto com a tecnologia
	que pretende se especializar, pessoas que fazem isso tem um desempenho muito melhor.
	
	"Voce recebe para trabalhar 40 horas por semana resolvendo os problemas da sua emprega e nao os seus" Uncle Bob
	R: se a empresa te contratou para escrever uma solucao de software e voce nao esta pronto pra isso, e tem de ficar
	buscando ajuda na internet e em foruns, voce nao esta pronto para isso e voce esta tentando resolver um problema seu.
	
	Quando uma empresa te contrata para escrever o codigo e nao para tentar descobrir e aprender enquanto faz.
	A responsabilidade e sua, resolva problemas com excelencia.

	Quanto custa um codigo ruim?
	
	1- Alta rotatividade-> se voce e a pessoa mais capacitada tecnicamente, vai te frustrar e vai buscar algo mais desafiador
	e se isso acontecer com outras pessoas a empresa vai ter de renovar seus funcionarios e isso vai fazer com que a qualidade
	caia ao inves de subir.
	2- Demora nas entregar de novas funcionalidades->codigo ruim e dificil de manter, entender, propor mundancas ou planejar
	refatoramento.
	3- Dificuldade na manutencao-> nenhum software bem escrito apresenta dificuldades de manter, pode ate ser complexo,
	mas nao dificil.
	4- Alta incidencia de bugs-> e um sinal de que o codigo nao esta legal, pode estar faltando testes ou com pouca qualidade.
	5- Perda de confianca do cliente-> uma entrega de mal qualidade, a proxima entrega o cliente nao espera algo bom.
	6- Desmotivacao profissional-> se tivermos de trabalhar com codigo ruim, devemos fazer o nosso melhor.
	7- Mais tempo depurando do que escrevendo codigo-> se o codigo nao e bom passamos mais tempo depurando do que escrevendo
	funcionalidades, o custo disso e impactar pessoas, sentimentos, problemas nao mensuraveis e tudo isso pode ser evitados
	com um pouco de qualidade de codigo e comprometimento, para conseguir isso precisamos assumir os problemas e influenciar
	outras pessoas e os menos experientes.
	
	
	
Aula 33: Como medir um bom codigo?

Quais sao os criterios:
	Linhas de codigo-> codigos ruins apresentam "mal cheiro", nao ha uma quantidade especifica que determina bom ou mal codigo,
	mas quantidade excessiva em uma funcionalidade simples indica algo de errado, exemplo: um cadastro de cliente com 5 mil linhas
	e no minimo estranho.
	
	Numero de metodos: tambem nao ha como definir uma quantidade ideal, e importante avaliar a responsabilidade da classe para
	identificar se temos poucos ou muitos metodos em uma classe.
	
	Numero de classes: dada uma aplicacao que faz muita coisa com poucas classes, da pra ver que tem problemas, pois o
	desenvolvedor pode nao ter separado as responsabilidades e programou de forma procedural sem usar a orientacao a objetos.
	
	Linhas de codigo por metodo: um determinado metodo deveria ter algumas linhas de codigo como limite, se fugir deste padrao
	o mesmo pode ser simplificado.
	
	Complexidade ciclomatica: excesso de if`s dentro de um codigo, isso e dificil de testar, alto nivel de complexidade
	demonstra que seu codigo nao foi bem escrito.
	
	Numero de estruturas de decisao: outras estruturas alem do if em exagero representam um codigo mais escrito, o programador
	que nao tem dominio total da linguagem ou do framework tende a ser o mais simplista possivel, buscando resolver tudo atraves
	do if/else, ele vai criar codigos muito longos e de alta complexidade.
	
	Nomes significativos(que revelem especifidade)!:
	
	Escolha nomes que revelem a intencao!-> o nome de uma classe, camada ou metodo deve demonstrar porque ele existe, o que faz e 
	como e usado.
	
	escrever codigo de maneira que as pessoas possam entender.
	
	*Utilizar nomes faceis de encontrar
	*Nomes pronunciaveis
	*Evite siglas ou acronimos
	*Nao economize em palavras-> nao tenha medo de escrever metodos com nomes grandes, peque pelo exceso do que pela falha.
	*Revele a intencao do codigo.
	
	Evite palavras que podem ser variaveis ou palavras reservadas.
	Evite dar nome com tipo da variavel, o tipo nao precise estar no nome.
	Evite trocadilhos, nao misture idiomas, nao mescle nomes, no maximo usar nomes de patterns.
	
	Nao existe um padrao exato a ser seguido, essas dicas sao para ajudar a corrigir pequenos habitos ruins,
	tentar mensurar o tamaho e responsabilidade, o Solid ajuda com isso, sempre validar se o entendimento esta claro
	para todos.
	
Aula 34: Boas praticas

Boas praticas segundo o livro clean code:

	1- Geral
	
	Nomes das classes devem ser substantivos e nao conter verbos.
	Ex.: ClienteRepository
	
	Nomes dos metodos devem conter verbos de preferencia no infinitivo
	Ex.: AdicionarClientes
	
	2- Nao seja generico:
	exemplos a serem evitados->
	
	//processa folha de pagamento
	Processa();
	
	//calcula imposto de renda
	Calcula();
	
	Exempos corretos:
	
	ProcessarFolhaPagamento();
	
	CalcularImpostoRenda();

	Obs.: nao economizou palavras e foi explicito
	
	3- Menos e mais
	
	"A primeira regra dos metodos e que eles devem ser pequenos, a segunda regra e que eles devem ser menores ainda." 
	Uncle Bob
	Obs.: e uma brincadeira para forcar que sejam pequenos.
	
	4- Parametros: 
	
	metodos <= 20 linhas-> metodo que tem mais de 20 linhas talvez nao esteja errado, mas pode ser um sinal,
	talvez possa refatora-lo, talvez esteja muito verboso, usando muito if quando poderia usar operador ternario, declarando
	variaveis que poderiam ser criadas dentro do escopo.
	
	linhas <= 100 caracteres -> nao esta escrito na pedra, pode passar um pouco e ser melhor, linhas com mais de 100 caracteres
	podem ser refatoradas, colocadas dentro de um metodo ou quebradas.
	
	classe <= 500 linhas-> pode ter 510, ou 600, mas se estiver muito acima disso, nao e um bom sinal. e indica que pode
	ser refatorada, indica que a classe pode estar fazendo mais do que sua responsabilidade, ou a responsabilidade pode
	ser quebrada em outra responsabilidade para complemento.
	
	5- Metodos
	
	*extraia trechos em metodos privados-> nem tudo que executamos precisa estar publido.
	*metodos devem fazer apenas 1 coisa, faze-la certa e somente faze-la.
	*evite muitos parametros-> metodos que recebem 10 parametros, voce pode criar um objeto, nao existe regra
	para quantidade, mas o recomendavel e no maximo 10 parametros.
	*nao deixe o metodo mentir, dizendo que faz algo e faz outra de forma escondida->exemplo: ProcessaFolhaPagamento()
	dentro dele envia um e-mail, mandar email pode ate fazer parte do processamento, mas entao este deve estar na 
	orquestracao do fluxo.
	*se o metodo tiver mais de uma responsabilidade extraia em mais metodos->e muito dificil testar metodos que fazem muitas
	coisas, se ele falhar vai ser dificil entender o motivo.
	Obs.: Arquivos de classes devem conter apenas 1 classe.
	*Leia o seu metodo de cima para baixo como uma narrativa, ele deve fazer sentido.
	*Aplique uma boa identacao-> isso diz respeito a hierarquia do processo.
		
Aula 35: Devo comentar meu codigo?

	1- Comentarios nao vao ajudar um codigo ruim a ser melhor interpretado, uma vez que a implementacao que precisava clara nao e.
	2- Um codigo que requer comentarios precisa ser reescrito.->O codigo pode estar muito complexo ou com responsabilidade excessiva.
	3- Nao deixei trechos de codigo comentados., 

Quando devo comentar?

	1- Aletar consequencias que pode vir a causar->investigando um problema.
	2- Licencas, direitos autorais, cabecalho, etc.
	3- Necessidade de explicar uma regra de negocio interna.
	4- Decisoes de design de codigo. -> usou um antipattern e era a necessidade, de preferencia colocar um todo:, em especial
	se ao refatorar voce se deparou com um problema, e quem tentar fazer aquilo provavelmente vai se deparar com o mesmo problema.
	
Aula 36: Tratamento de erros

1- Boas praticss no tratamento de erros
	*Tratar e prever possiveis excecoes e de responsabilidade do desenvolvedor.
	Obs.: Nao encher o codigo de try/catch, criar uma forma global(ex. interceptor) de capturar exceptions e 
	trata-las por meio de log

	*Retorne exceptions e nao codigos de erros ou mensagem personalizada.
	Obs.: informacoes que permitam identificar o problema e porque ele ocorreu.
	
	*Informe o maximo que puder em sua exceptions
	Obs.: toda exception tem um rastro do problema, nao mostrar detalhes do erro para o cliente.
	
	*Se necessario crie exceptions personalizadas para um problema especifico.
	Obs.: cria uma classe pagamento exception herdando da exception.
	boa pratica-> ter um catch especifico pra exceptions especificas e um catch generico para excessoes genericas,
	dar tratamento personalizado para um problema especifico.
	
	*Nao retorne null
	Ons.: Catch mudo, quando temos uma exception retornando nulo ou nao retornando nada, o usuario que esta
	utilizando nao vai ter ciencia que houve um problema, e vai continuar gerando mais erros.
	
	*Regra dos escoteiros: deixe a area de acampamento mais limpa de como voce a encontrou.
	Obs.: crie task especifica para refatoracao.
	
Modulo Design Patterns
Aula 37: Apresentacao

1- Design Patterns sao padroes de codigo para a solucao de problemas conhecidos.
2- O objetivo e nao reinventar a roda e aplicar uma solucao com um bom design de codigo.
3- O conceito de padroes foi introduzido por 4 desenvolvedores intitulados "Gang of four" GoF
e hoje conta com 23 padroes fundamentais.
4- Atualmente existem mais de 80 padroes conhecidos que sao em geral variacoes dos 23 patterns do GoF.

os 23 padroes sao:

Abstract Factory - C - Azul
Adapter - S - Salmao
Brigde - S - Salmao
Builder - C - Azul
Chain of Responsability - B - Verde
Command - B - Verde
Composite - S - Salmao
Decorator - S - Salmao
Facade - S - Salmao
Factory Method - C - Azul
Flyweight - S - Salmao
Interpreter - B - Verde
Iterator - B - Verde
Mediator - B - Verde
Memento - B - Verde
Prototype - C - Azul
Proxy - S - Salmao
Observer - B - Verde
Singleton - C - Azul
State - B - Verde
Strategy - B - Verde
Template Method - B - Verde
Visitor - B - Verde

Os padroes do GoF estao divididos em 3 familias:

Nome								Descricao
Creational Patterns(Criacao)		Fornecem meios de criacao de um objeto e de como ele sera instanciado.
Obs.: Aprender a resolver os problemas de como criar objetos da forma correta.
Meio que concorre com a ideia de injecao de dependencia, mas ao mesmo tempo nao concorre, a ideia e usa-los
em conjunto.

Structural Patterns(Estrutural)		Tratam da composicao de objetos por herancas e interfaces para diferentes
									funcionalidades.
Obs.: Quando precisamos modelar objetos, estes padroes vao ajudar.
Como montar a composicao de objetos para que atendam a necessidade com um bom design e o polimorfismo.

Behavioral Patterns(Comportamental)	Tratam das interacoes e comunicacao entre os objetos alem da divisao de
									responsabilidades.
Obs.: Como os objetos se interagem.

Aula 38: 
Aula 39:
Aula 40:

Modulo Arquitetura de software
Modulo Encerramento
