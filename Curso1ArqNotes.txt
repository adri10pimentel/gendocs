Aula 1:
Aula 2:
Aula 3:
Aula 4:
Aula 5:
Aula 6:
Arquiteto de Software

Objetivo: Projetar aplicacoes utilizando conceitos de arquitetura e 
boas praticas de desenvolvimento.

Artefatos entregaveis: Frameworks, arquiteturas(definindo a arquitetura) / modelos de referencia, 
analise de cenarios / desafios tecnicos.
O Arquiteto de SW e como se fosse uma biblioteca de solucoes de SW para o cenario e toma a 
melhor decisao com bate na estrategia da empresa e no desafio tecnico.
Qual componente, tecnologia e abordagem sera usada.
Conceitos chave: Qualidade, Flexibilidade, Performance, Reuso, Testabilidade,
Escalabilidade e Seguranca.

Ele precisa saber o custo da ferramenta, tem uma serie de requisitos pessoais e pode nao ser para todo o desenvolvedor.
saber lidar com restricoes e proibicoes.

Figura escolhida:
Arquitetura hexagonal aka: arquitetura de portas e adapters
Entenda tudo disso, mas use somente o que for necessario.

Primary/Driving Adapters																				Secondary/Driven Adapters
																	Command Query Bus		|		Event Bus
USER		HTTP
			|					-> ADMIN GUI Views & Controllers 	-> Queries	|					CQBUS->Message BUS->Message Queue Adapter->Message Queue
COMPUTER	|		WEB SERVER	-> SOAP/REST Controllers			-> Commands	|					EBUS->Event BUS Adapter-|^
			|					-> CONSUMER GUI Views & Controllers	-> Services	-> Application Core	Notifications->SMS Adapter->SMS Server
USER		|																	|								 ->Email Adapter->Mailing Server
																				|					Shared Kernel
USER	->	CLI-command line interface	-> console commands						|					Search->Search adapter->Search Engine(ie. Elasticsearch)
																									Persistence->ORM Adapter->ORM->MySQL Adapter->PRD DB(MySQL)
																																|->SqLite Adapter->TST DB(SqLite)
																																
																		User Interface		|		Infrastructure
																		
Aula 7:
Outros tipos de arquitetos:

Arquiteto de dados
Arquiteto de TI -> data centers, etc.
Arquiteto de nuvem
Etc...

A IASA reconhece a existencia deles, porem os entende como customizados para atender a necessidades especificas das empresas.

Aula 8:
Perfil do Arquiteto de SW

Objetivo principal: projetar uma solucao compativel com os requisitos atuais da corporacao, que tenha flexibilidade suficiente 
para comportar mudancas futuras e/ou novos requisitos resultantes de sua evolucao ao longo do tempo.

ser adaptavel a cultura da empresa
Para empresas conservadoras: muitos anos de existencia, multinacional, nao gere revolucoes se adapte ao que existe.
Para empresas startups: buscar inovacao, se adaptar ao budget restrito e exigem resultado atraves de tecnologias modernas.

ser responsavel pela qualidade tecnica do entregavel, atuar no apoio tecnico de toda equipe e ajudar nas decisoes necessarias.
Obs: nao so esperar que o time atenda a qualidade tecnica esperada, acompanhar e ajustar e reconhecer as limitacoes tecnicas da equipe,
muitas vezes tem de ser instrutor para prover treinamentos para a equipe, buscar ter um backup de si mesmo, alguem que consiga assumir seu lugar,
sucessor, caso voce venha a subir de nivel para C-level, ajudar a equipe a tomar decisoes, a equipe e um organismo vivo, sinergia entre o arquiteto e a equipe.

Promover comunicacao do time, envolvendo e delegando as decisoes de arquitetura com toda a equipe.
Obs.: ser um bom orador para envolver o time, nao da para ser introspectivo, precisa explicar o que quer, para que as pessoas possam te defender caso necessario.
para que as pessoas saibam o porque de voce esta ali.

Aula 9:
Requisitos tecnicos "Hard skills":
1- Profundo conhecimento em programacao e componentizacao.
	Componentizacao: transformar um conjunto de algoritmos e tecnologias em um componente responsavel.
	ter experiencias solidas em projetos, atuar ao lado de outros arquitetos, conquistar cases de sucesso.

2- dominar amplamente alguma plataforma de desenvolvimento, frameworks, ferramentas e modelagem tecnica.
exemplo eu: plataforma web, frameworks: .net, angular, ferramentas: IDE`s, modelagem tecnica: EA, Bizzagi, Power Designer

3- Conhecer abordagens de arquitetura e padroes para a solucao de problemas. (para a area de atuacao)
Obs.: Arquitetura web e diferente de uma arquitetura industrial por exemplo.

4- Conhecer as tecnicas de design de codigo e qualidade para permitir uma facil manutencao e testabilidade.
um arquiteto pode entregar um template ou uma primeira funcionalidade codificada para ser usado como referencia e doutrinacao dos demais membro dos times.

Aula 10:
Requisitos pessoais "Soft skills"

Lideranca - envolve pessoas, lider natural, onde for colocado, com o tempo ele vai liderar aquelas pessoas, nao e apenas conquistar mas sim envolver, um lider 
tem de ser respeitado nao porque ele tem poder ou por estar a frente, mas porque ele e a melhor pessoa para escolher o destino.

Comunicacao - um lider precisa ser comunicativo, uma pessoa nao comunicativa nao dificilmente vai ter lideranca, mesmo que lideranca nao esteja ligada a ser 
apenas um bom comunicador, investir tempo para aperfeicoar o meu nivel de comunicacao, comunicar com pessoas que me lideram, comunicacao fluente e autoconfianca.

Proatividade - ele nao pode esperar as coisas acontecerem, precisa prever os acontecimentos, estar preparados antes de ocorrer e tomar iniciativa, antenado e 
sempre ligado no que vai acontecer.

mindset empreendedor - mente empreendedora, postura de dono, buscar formas rentaveis de otimizar o uso de recursos e maximizar resultados da empresa, como se eu
fosse a pessoa que esta perdendo dinheiro.

humildade - ter cuidado como se porta, reconhecer suas limitacoes, falhas e defeitos, nunca se colocar como quem sabe de tudo, manda e desmanda.

resumo:
	tomar boas decisoes
	estar aberto a criticas e sugestoes
	ser um profundo pesquisador
	ser didatico
	saber delegar tarefas
	saber questionar: colocar em palavras a sua visao para que a pessoa reflita aquilo que esta colocando sem gerar confronto
	saber conduzir as discussoes->saber a hora de comecar a falar, parar de falar, dar abertura para as pessoas, poderar os pontos da discussao
	saber conversar com diferentes niveis hierarquicos
	estar sempre aberto a novas tecnologias ->Leitura, eventos, etc...
	estar atualizado com o mercado
	ter maturidade e equibilibrio emocional->nunca demonstrar fraqueza ou emocao agressiva
	pensamento estrategico
	reconhecer e assumir os proprios erros e de sua equipe->se coloque a frente e proteja seus liderados
	
Aula 11:
Mitos sobre o arquiteto de software

1-O arquiteto nao programa, apenas projeta, documenta e lidera.
2-Um desenvolvedor senior pode assumir o papel de arquiteto.
3-O arquiteto e um desenvolvedor com muito tempo de experiencia, "arquiteto de cadeira".
4-Para ser um arquiteto basta estudar tecnicas de arquitetura de software.
5-O arquiteto trabalha em ambiente isolado ou diferenciado da equipe.
6-O arquitet o e uma autoridade tecnico e nao deve ser questionado.
7-O arquiteto e um gerente tecnico.
8-O arquiteto e um profissional com graducao em arquitetura de software.
9-O arquiteto e um profissional que esta na liderenca de um projeto.
Obs.: cobranca de prazo, etc, e um acumulo de funcao que o arquiteto deve aceitar.

Aula 12:
Orientacao a objeto - OOP

Pilares fundamentais:

Estado, Comportamento, abstracao, Heranca, Poliformismo, Encapsulamento.

E essencial possuir um claro conhecimento dos principios da orientacao a objetos para poder aplicar as melhores
praticas de design de codigo, padroes e abordagens de arquitetura.

Objetivo: buscar o baixo acoplamento e a alta coesao.

Acoplamento: dependencia direta entre um objeto e outro.
Coesao: Objetos executando uma unica responsabilidade livres de uma dependencia direta com um outro objeto.

Aula 13:
Estado e comportamento

Classe: estrutura de codigo que tem a funcao de mapear um objeto do mundo real(uma pessoa, um objeto real, etc).
Objeto: quando temos uma classe  instanciada com valores na memoria.
Estado: estado e representado pelas propriedades da classe quando ela contem x informacoes ela esta em um estado x.
Comportamento: e quando geramos uma nova informacao atraves da propria classe, ex. metodo calcularIdade, apos receber a informacao data de nascimento..
Comportamento2: o metodo tambem pode alterar o estado da classe, por exemplo um metodo pode alterar o nome da pessoa.

resumo:
estado -> entender que a classe possui propriedade que possuem informacoes que estao na instancia da classe(objeto).
comportamento -> sao metodos que processam a informacao(gerando novas informacoes) ou que alteram o estado da entidade.

metodo -comportamento
estado -propriedades

Aula 14:
Heranca

Funcionario herdando de pessoa

O Funcionario e uma pessoa, quando herdamos de pessoa estamos extendendo a classe pessoa com a especializacao de funcionario.
poderiamos estender por exemplo a classe pessoa como cliente, pois ambos sao pessoas.

nem sempre a heranca deve ser utilizada.

toda ver que herdamos de uma outra classe, estamos absorvendo o estado e os comportamentos daquela outra classe.

para usar a heranca deve usar sempre a frase: a classe que esta herdando eh um classe que esta sendo herdada?
mesmo que o criterio eh um funcione, temos que avaliar se vale ou nao a pena usar heranca ou se estamos somente economizar linhas de codigo na implementacao.

nas proximas aulas vamos entender quando e como utilizar heranca.

Aula 15:
Abstracao

abstracao eh um pilar suportado pela heranca, ou seja oferecer um conjunto que estados e comportamentos que abstraem uma certa especializacao.

exemplo:
classe abstrata eletrodomestico
todo eletrodomestico tem:
nome
voltagem
e se comporta:
ligando
desligando

Obs.: quando temos um metodo abstrato nao somos obrigados a implementar seus comportamentos.
quando eu defindo isso, a classe filha vai ser responsavel por implementar seus proprios comportamentos de acordo com seu funcionamento.
Quando marcamos uma classe com o modificador abstrato estamos proibindo a instancia-la, esta classe soh podera ser herdada, nunca instanciada.

se temos a missao que criar uma super classe para heranca, o conceito de abstract e essencial.

o conceito de abstracao eh a base para o polimorfismo e encapsulamento.

a abstracao pode facilitar e criar regras para que suas classes nao sejam criadas de forma errada.

simplificando abstracao eh: criar conceitos genericos que possam ser abstraidos por outras classes.

Aula 16:
Poliformismo

Poli - muitos, morfismo - comportamento

CafeteiraExpressa e um eletrodomestico, que tem comportamentos privados exemplo: aquecer a agua e moer os graos do cafe.

override - sobreescrever o comportamento de uma classe base para implementar o comportamento, por conta da classe abstrata Eletrodomestico eu sou abrigado a
sobreescrever e implementar.

na classe abstrata podemos ter metodos padrao que nao sejam abstratos e que serao herdados, porem a sobreescrita destes metodos nao e permitida nas classes herdadas.
se quisermos implementar algo e permitir sobreescrever, precisamos adicionar o modificador virtual.

Aula 17:
Encapsulamento

Oque eh?
Encapsular comportamentos atraves da exposicao de metodos publicos e privados.

Encapsulamento e fazer uso de metodos de uma classe sem saber como ele internamente funciona.

o ponto chave do encapsulamento sao os modificadores de acesso.

ref: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers

public - acessivel em qualquer codigo pelo propio o por outro assembly que o referencie.
private - acessivel somente pelo codigo dentro da classe ou estrutura.
protected - acessivel somente pelo codigo de sua classe ou classe derivada.
internal - acessivel por qualquer codigo no mesmo assembly mas nao em outro assembly.
protected internal - acessivel em qualquer codigo no assembly em que foi declarado, mas somente
em uma classe derivada em outro assembly.
private protected - tipo ou membro pode ser acessado por tipos derivados da classe declarada em seu proprio assembly.

Aula 18:
Interface x Implementacao

Sempre e melhor defender o uso de uma interface do que uma simples implementacao pura.

A interface e uma especie de contrato, toda a classe que implementa uma interface e obrigado a implementar os metodos da interface, isso pode
ser confundido com o uso da classe abstrata pois apesar da classe abstrata tambem forcar a implementacao de metodos, tambem implementa alguns comportamentos
derivados, ja a interface e um contrato simples, ou seja, se vc esta implementando esta interface vc e obrigado a fazer a implementacao dos metodos nela presentes.

tem de cumprir o contrato.
podemos criar uma classe fake que nao vai realizar a acao.

implementacao, chamar a classe.

na implementacao, voce usa classes concretas e em caso de alteracao a classe quebra.
a classe que implementa e a classe que esta sendo implementada podem quebrar.

ao usar a abstracao com interfaces, o codigo nao quebra em caso de modificacao de uma classe que implementa a interface, porque esta abstraido atraves do contrato
e nao sendo implementado atraves da implementacao forte da classe concreta.

no caso de alteracao no construtor, resolver atraves da injecao de dependencia como ele ira ensinar mais a frente no curso.

Aula 19:
Heranca x Composicao

Exemplo de heranca->PessoaFisica herda de Pessoa
public clase PessoaFisica : Pessoa

Obs.: conceito chave para pessoa, usar o criterio: eh um... no caso Pessoa Fisica e uma pessoa.

//e adiciona o atributo cpf.
public string cpf;

Exemplo de composicao->
public class PessoaFisica2
public Pessoa pessoa;
public string cpf;

Quando definir entre heranca e composicao?
R: no solid existe um principio que explica se uma classe deve herdar outra ou nao.

Resposta para o momento: desde de que a classe pai  nao sofra nenhuma deformacao de sua proposta, se a classe pai comecar a ser alterada
e criada caracteristicas que nao sao inerentes a sua proposta, eh um sinal que estamos forcando uma situacao que nao era pra acontecer, tbm e importante
observar que as caracteristicas que a classe pai possui tambem tem de atender o que a classe filho espera, uma heranca correta exige harmonia.

caso 2:
Repositorio Generico x Repositorio Especializado

quando herdamos, temos um acoplamento mais forte do que quando abstraimos.

com composicao podemos nos resgaurdar e nao expor metodos desnecessarios.

Obs.: prefira sempre uma composicao a uma heranca, pois favorece ao baixo acoplamento e alta coesao.

https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers

Quiz: se em um projeto de AssemblyA esta herdando de uma classe do AssemblyB, quais metodos do AssemblyB serao visiveis na classe derivada do AssemblyA?
R: metodos que tenham os modificadores public, protected e protected internal.

E em uma classe nao derivada, quais metodos do AssemblyB estarao visiveis?
R: somente os metodos com o modificador public.

Aula 20:
Solid - single responsability principle, open closed principle, Liskov substitution principle, interface segregation principle, dependency invertion principle
Solid esta ligado a OOP, e algo que tem de ser aplicado o tempo todo durante a codificacao.

SOLID e um acronimo dos 5 primeiros principios da programacao orientada a objetos e design de codigo identificados por Robert C Martin(Uncle Bob) por volta 
dos anos 2000.

por volta dos anos 2000, Uncle Bob nao criou ou documentou, ele observou os principios destacados por outras pessoas e os unificou como se fosse uma regra 
de ouro que forma a palavra solid, que representa um codigo solido, forte.

Os principios do SOLID devem ser aplicados para se obter os reais beneficios da programacao orientada a objetos.

nao adianta usar OOP sem utilizar o SOLID, esperando obter algum tipo de beneficio, nao adianta usar somente uma letra ou beneficio, esse nao e um padrao que voce deve escolher ou nao se vai aplicar,
o solid e o fundamento da Orientacao a objetos.

Os beneficios sao:
1- facilidade de manter, adaptar e se ajustar a alteracoes de escopo.
essa frase resume a maior parte das aplicacoes do SOLID, a maior dor das aplicacoes manter, adaptar e ajustar, se nao usamos a escrita de codigo corretamente, 
podemos nao conseguir entregar software ao mesmo tempo que o mercado espera ou para tornar seu produto competitivo.

2- ser testavel e de facil entendimento.
para o ser codigo ser testavel ele precisa ser um bom codigo, se ele nao e testavel, e porque nao e um bom codigo, o bom codigo e um codigo de facil entendimento.

3- ser extensivel para extensivel a alteracoes com o menor esforco necessario.
todos ja devem ter passado por isso, precisar alterar um botao e precisar mexer na aplicacao quase como um todo, pois ela esta toda acoplada.
isso e um sinal de codigo ruim.

4- fornecer o maximo de reaproveitamento.
a orientacao a objetos e uma opcao melhor do que a programacao procedural por oferecer mais opcoes de reaproveitamento de codigo, e se o seu codigo nao oferece
o maximo de reaproveitamento e porque faltou design de codigo por meio dos principios do solid e demais praticas.

5- que permaneca o maximo de tempo possivel em utilizacao.
se nos ouvirmos "se quiser que eu faca isso na aplicacao vou precisar reescreve-la quase que inteira", o programador que fala isso esta errado ao falar,
principalmente se ele tiver criado a aplicacao, pois apesar do software precisar de alteracoes para se adaptar, a alteracao deve ser sempre a minima possivel,
uma aplicacao boa e bem escrita e facil de mexer, tanto de alterar como de acrescentar funcionalidades, o intuito do trabalho e manter o codigo o maximo de tempo
possivel em utilizacao, ate que ele nao seja mais necessario, o sw so sai de utilizacao quando ele nao e mais necessario.

ele nao deve ser reescrito para tentar atender a uma necessidade que ele falhou em atender pela primeira vez.

Problemas evitados com SOLID:
1- Dificuldade ma testabilidade / criacao de testes de unidade.
2- Codigo macarronico / sem estrutura padrao.
o codigo da sinais, nao encontrar padroes e algo grave.
3- Dificuldades em isolar funcionalidades.
muito acoplamento, quando uma classe nao eh so responsavel pelo que ela faz e voce precisa entender tudo aquilo que as outras fazem para que ela faca sentido.
4- Duplicacao de codigo, uma alteracao precisa ser replicada em N pontos.
sem isso perdemos o beneficio da reusabilidade.
5- fragilidade, o codigo quebra facilmente apos alguma mudanca.
em antagonismo a palavra solid que nos remete um codigo solido, forte, inquebravel.

exemplo: alteracao no cadastro de cliente quebrando/impactando o processo de vendas.

ponto chave: evitar problemas em tempo de escrita de codigo.

Aula 21:
SRP - Single responsability principle

"A class should have one, and only one reason to change".
"Uma classe so pode ter, e apenas um motivo para ser modificada".

este e o principio mais simples e mais importante do solid, a responsabilidade definida se da atraves do que a classe tem de fazer, exemplo: uma classe que envia
email, porque ela sera alterada um dia? R: porque neste dia a forma de se mandar email mudou, se alem de enviar email a classe tambem tiver de formatar texto, ela
tambem tiver controle texto, imagem, anexo, ela vai ter mais de um motivo para mudar.

O principio da responsabilidade unica nao se aplica apenas a uma classe, se aplica a tudo, uma camada de negocios so pode tratar de negocios, nao se preocupar com infra
e etc...

nao quer dizer que uma classe so pode ter um metodo, esta mais no porque a classe precisa ser criada.

uma classe que envia email pode ter varios metodos que ajudam a compor o envio de email, mas nao pode fugir da responsabilidade que e o envio de emcil.

sempre pensar: estamos invadindo a responsabilidade que deveria ser de outra classe?

exemplos:

violacao->
temos a classe cliente com suas propriedades para definicao de estado, e temos um comportamento adicionar cliente, ou seja uma classe de entidade que faz a
propria persistencia e envio de email, e isso passa a sua propria responsabilidade.

o problema maior e que e dificil de testar e identificar onde ocorre a falha.

solucao->
obs.: nao e a solucao ideal pois precisa dos demais principios do solid.

gerar mais classes:
cliente->possui os atributos e um comportamento que e a validacao do cliente atraves de verificar o email e o cpf validos.
clienteRepository-> metodo adicionarCliente que conecta com o banco de dados e faz a persistencia,
clienteService -> metodo que orquestra tudo
cpf -> possui o estado e o comportamento de um cpf
email -> possui o estado e o comportamento de um email
emailService -> efetua o disparo de um email

pergunta: mas a classe clienteService nao esta acumulando responsabilidades?
R: nao, a proposta dela e ser um workflow e esta e a sua responsabilidade.

Obs.: podemos afirmar que todos os demais principios sao para atender o SRP, e no final de todos os principios vamos ver que o SRP foi otimizado.

este e o principio mais simples e mais importante, ele nao exige nenhuma tecnica, basta apenas separar.

Aula 22:
OCP - Open closed principle

ponto chave: esternder a classe principal em funcionalidades secundarias.

Aula 23:
LSP - Liskov substitution principle

Barbara Liskov foi a primeira mulher dos estados unidos a obter um phd em ciencia da computacao.

ponto chave: subclasses devem ser substituiveis por suas superclasses.

"se nada como um pato, voa como um pato e precisa de baterias, provavelmente voce possui um problema de abstracao"
entendendo:

o pato voa e nada, o pato de banheira e uma especializacao do pato, se no pato de banheira tiver de colocar pilhas e seu estado e comportamento nao puderem
ser substituidos pelo pato original, e porque existe uma desconexao com o pato original de onde houve a heranca.

O LSP e a prova real da heranca.

exemplo: quadrado x retangulo

uma das formas de resolver o LSP e implementando o OCP.